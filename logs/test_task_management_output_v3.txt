============================= test session starts =============================
platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0
rootdir: D:\EMS
plugins: anyio-4.12.1
collected 1 item

tests\test_task_management.py EE                                         [100%]

=================================== ERRORS ====================================
_____________ ERROR at setup of test_task_lifecycle_with_subtasks _____________

self = <sqlalchemy.engine.base.Connection object at 0x000001D36D3D8E90>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x000001D36C93ECF0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x000001D36CF25350>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x000001D36D044E10>
parameters = [{'dob': None, 'email': 'mgr_tm@ems.com', 'hashed_password': '$2b$12$E9nt8A9a76CEFFJL6Mmj7.NTfjg9F3lHXqyRiw9G.lcOzn3BC6Xzm', 'is_active': True, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x000001D36C93ECF0>
cursor = <cursor object at 0x000001D36D3E8BA0; closed: -1>
statement = 'INSERT INTO users (username, email, hashed_password, role, is_active, dob, mobile_number, team_name, team_id) VALUES ...hashed_password)s, %(role)s, %(is_active)s, %(dob)s, %(mobile_number)s, %(team_name)s, %(team_id)s) RETURNING users.id'
parameters = {'dob': None, 'email': 'mgr_tm@ems.com', 'hashed_password': '$2b$12$E9nt8A9a76CEFFJL6Mmj7.NTfjg9F3lHXqyRiw9G.lcOzn3BC6Xzm', 'is_active': True, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x000001D36CF25350>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "ix_users_email"
E       DETAIL:  Key (email)=(mgr_tm@ems.com) already exists.

venv\Lib\site-packages\sqlalchemy\engine\default.py:952: UniqueViolation

The above exception was the direct cause of the following exception:

test_db = <sqlalchemy.orm.session.Session object at 0x000001D36A3B9010>

    @pytest.fixture(scope="module")
    def manager_token(test_db):
        user = User(username="manager_tm", email="mgr_tm@ems.com", hashed_password=get_password_hash("password"), role="manager", is_active=True)
        test_db.add(user)
>       test_db.commit()

tests\test_task_management.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
venv\Lib\site-packages\sqlalchemy\sql\elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\Lib\site-packages\sqlalchemy\engine\base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x000001D36C93ECF0>
cursor = <cursor object at 0x000001D36D3E8BA0; closed: -1>
statement = 'INSERT INTO users (username, email, hashed_password, role, is_active, dob, mobile_number, team_name, team_id) VALUES ...hashed_password)s, %(role)s, %(is_active)s, %(dob)s, %(mobile_number)s, %(team_name)s, %(team_id)s) RETURNING users.id'
parameters = {'dob': None, 'email': 'mgr_tm@ems.com', 'hashed_password': '$2b$12$E9nt8A9a76CEFFJL6Mmj7.NTfjg9F3lHXqyRiw9G.lcOzn3BC6Xzm', 'is_active': True, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x000001D36CF25350>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.errors.UniqueViolation) duplicate key value violates unique constraint "ix_users_email"
E       DETAIL:  Key (email)=(mgr_tm@ems.com) already exists.
E       
E       [SQL: INSERT INTO users (username, email, hashed_password, role, is_active, dob, mobile_number, team_name, team_id) VALUES (%(username)s, %(email)s, %(hashed_password)s, %(role)s, %(is_active)s, %(dob)s, %(mobile_number)s, %(team_name)s, %(team_id)s) RETURNING users.id]
E       [parameters: {'username': 'manager_tm', 'email': 'mgr_tm@ems.com', 'hashed_password': '$2b$12$E9nt8A9a76CEFFJL6Mmj7.NTfjg9F3lHXqyRiw9G.lcOzn3BC6Xzm', 'role': 'manager', 'is_active': True, 'dob': None, 'mobile_number': None, 'team_name': None, 'team_id': None}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError
___________ ERROR at teardown of test_task_lifecycle_with_subtasks ____________

tables = [Table('users', MetaData(), Column('id', Integer(), table=<users>, primary_key=True, nullable=False), Column('username...alarElementColumnDefault(False)), Column('task_id', Integer(), ForeignKey('tasks.id'), table=<subtasks>), schema=None)]
filter_fn = <function SchemaDropper.visit_metadata.<locals>.<lambda> at 0x000001D36D3F1080>
extra_dependencies = None, _warn_for_cycles = False

    def sort_tables_and_constraints(
        tables, filter_fn=None, extra_dependencies=None, _warn_for_cycles=False
    ):
        """Sort a collection of :class:`_schema.Table`  /
        :class:`_schema.ForeignKeyConstraint`
        objects.
    
        This is a dependency-ordered sort which will emit tuples of
        ``(Table, [ForeignKeyConstraint, ...])`` such that each
        :class:`_schema.Table` follows its dependent :class:`_schema.Table`
        objects.
        Remaining :class:`_schema.ForeignKeyConstraint`
        objects that are separate due to
        dependency rules not satisfied by the sort are emitted afterwards
        as ``(None, [ForeignKeyConstraint ...])``.
    
        Tables are dependent on another based on the presence of
        :class:`_schema.ForeignKeyConstraint` objects, explicit dependencies
        added by :meth:`_schema.Table.add_is_dependent_on`,
        as well as dependencies
        stated here using the :paramref:`~.sort_tables_and_constraints.skip_fn`
        and/or :paramref:`~.sort_tables_and_constraints.extra_dependencies`
        parameters.
    
        :param tables: a sequence of :class:`_schema.Table` objects.
    
        :param filter_fn: optional callable which will be passed a
         :class:`_schema.ForeignKeyConstraint` object,
         and returns a value based on
         whether this constraint should definitely be included or excluded as
         an inline constraint, or neither.   If it returns False, the constraint
         will definitely be included as a dependency that cannot be subject
         to ALTER; if True, it will **only** be included as an ALTER result at
         the end.   Returning None means the constraint is included in the
         table-based result unless it is detected as part of a dependency cycle.
    
        :param extra_dependencies: a sequence of 2-tuples of tables which will
         also be considered as dependent on each other.
    
        .. seealso::
    
            :func:`.sort_tables`
    
    
        """
    
        fixed_dependencies = set()
        mutable_dependencies = set()
    
        if extra_dependencies is not None:
            fixed_dependencies.update(extra_dependencies)
    
        remaining_fkcs = set()
        for table in tables:
            for fkc in table.foreign_key_constraints:
                if fkc.use_alter is True:
                    remaining_fkcs.add(fkc)
                    continue
    
                if filter_fn:
                    filtered = filter_fn(fkc)
    
                    if filtered is True:
                        remaining_fkcs.add(fkc)
                        continue
    
                dependent_on = fkc.referred_table
                if dependent_on is not table:
                    mutable_dependencies.add((dependent_on, table))
    
            fixed_dependencies.update(
                (parent, table) for parent in table._extra_dependencies
            )
    
        try:
>           candidate_sort = list(
                topological.sort(
                    fixed_dependencies.union(mutable_dependencies),
                    tables,
                )
            )

venv\Lib\site-packages\sqlalchemy\sql\ddl.py:1403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\util\topological.py:73: in sort
    for set_ in sort_as_subsets(tuples, allitems):
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tuples = {(Table('teams', MetaData(), Column('id', Integer(), table=<teams>, primary_key=True, nullable=False), Column('name', ...ignKey('users.id'), table=<tasks>), Column('team_id', Integer(), ForeignKey('teams.id'), table=<tasks>), schema=None))}
allitems = [Table('users', MetaData(), Column('id', Integer(), table=<users>, primary_key=True, nullable=False), Column('username...alarElementColumnDefault(False)), Column('task_id', Integer(), ForeignKey('tasks.id'), table=<subtasks>), schema=None)]

    def sort_as_subsets(
        tuples: Collection[Tuple[_T, _T]], allitems: Collection[_T]
    ) -> Iterator[Sequence[_T]]:
        edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
        for parent, child in tuples:
            edges[child].add(parent)
    
        todo = list(allitems)
        todo_set = set(allitems)
    
        while todo_set:
            output = []
            for node in todo:
                if todo_set.isdisjoint(edges[node]):
                    output.append(node)
    
            if not output:
>               raise CircularDependencyError(
                    "Circular dependency detected.",
                    find_cycles(tuples, allitems),
                    _gen_edges(edges),
                )
E               sqlalchemy.exc.CircularDependencyError: Circular dependency detected. (Table('users', MetaData(), Column('id', Integer(), table=<users>, primary_key=True, nullable=False), Column('username', String(), table=<users>, nullable=False), Column('email', String(), table=<users>, nullable=False), Column('hashed_password', String(), table=<users>, nullable=False), Column('role', String(), table=<users>, nullable=False, default=ScalarElementColumnDefault('employee')), Column('is_active', Boolean(), table=<users>, default=ScalarElementColumnDefault(False)), Column('dob', String(), table=<users>), Column('mobile_number', String(), table=<users>), Column('team_name', String(), table=<users>), Column('team_id', Integer(), ForeignKey('teams.id'), table=<users>), schema=None), Table('teams', MetaData(), Column('id', Integer(), table=<teams>, primary_key=True, nullable=False), Column('name', String(), table=<teams>, nullable=False), Column('description', String(), table=<teams>), Column('created_at', DateTime(), table=<teams>, default=CallableColumnDefault(<function datetime.utcnow at 0x000001D36CAE63E0>)), Column('manager_id', Integer(), ForeignKey('users.id'), table=<teams>), schema=None))

venv\Lib\site-packages\sqlalchemy\util\topological.py:47: CircularDependencyError

During handling of the above exception, another exception occurred:

self = <sqlalchemy.sql.ddl.SchemaDropper object at 0x000001D36E179F90>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        try:
            unsorted_tables = [t for t in tables if self._can_drop_table(t)]
            collection = list(
                reversed(
>                   sort_tables_and_constraints(
                        unsorted_tables,
                        filter_fn=lambda constraint: (
                            False
                            if not self.dialect.supports_alter
                            or constraint.name is None
                            else None
                        ),
                    )
                )
            )

venv\Lib\site-packages\sqlalchemy\sql\ddl.py:1087: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\sql\ddl.py:1434: in sort_tables_and_constraints
    candidate_sort = list(
venv\Lib\site-packages\sqlalchemy\util\topological.py:73: in sort
    for set_ in sort_as_subsets(tuples, allitems):
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tuples = {(Table('teams', MetaData(), Column('id', Integer(), table=<teams>, primary_key=True, nullable=False), Column('name', ...ignKey('users.id'), table=<tasks>), Column('team_id', Integer(), ForeignKey('teams.id'), table=<tasks>), schema=None))}
allitems = [Table('users', MetaData(), Column('id', Integer(), table=<users>, primary_key=True, nullable=False), Column('username...alarElementColumnDefault(False)), Column('task_id', Integer(), ForeignKey('tasks.id'), table=<subtasks>), schema=None)]

    def sort_as_subsets(
        tuples: Collection[Tuple[_T, _T]], allitems: Collection[_T]
    ) -> Iterator[Sequence[_T]]:
        edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
        for parent, child in tuples:
            edges[child].add(parent)
    
        todo = list(allitems)
        todo_set = set(allitems)
    
        while todo_set:
            output = []
            for node in todo:
                if todo_set.isdisjoint(edges[node]):
                    output.append(node)
    
            if not output:
>               raise CircularDependencyError(
                    "Circular dependency detected.",
                    find_cycles(tuples, allitems),
                    _gen_edges(edges),
                )
E               sqlalchemy.exc.CircularDependencyError: Circular dependency detected. (Table('users', MetaData(), Column('id', Integer(), table=<users>, primary_key=True, nullable=False), Column('username', String(), table=<users>, nullable=False), Column('email', String(), table=<users>, nullable=False), Column('hashed_password', String(), table=<users>, nullable=False), Column('role', String(), table=<users>, nullable=False, default=ScalarElementColumnDefault('employee')), Column('is_active', Boolean(), table=<users>, default=ScalarElementColumnDefault(False)), Column('dob', String(), table=<users>), Column('mobile_number', String(), table=<users>), Column('team_name', String(), table=<users>), Column('team_id', Integer(), ForeignKey('teams.id'), table=<users>), schema=None), Table('teams', MetaData(), Column('id', Integer(), table=<teams>, primary_key=True, nullable=False), Column('name', String(), table=<teams>, nullable=False), Column('description', String(), table=<teams>), Column('created_at', DateTime(), table=<teams>, default=CallableColumnDefault(<function datetime.utcnow at 0x000001D36CAE63E0>)), Column('manager_id', Integer(), ForeignKey('users.id'), table=<teams>), schema=None))

venv\Lib\site-packages\sqlalchemy\util\topological.py:47: CircularDependencyError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="module")
    def test_db():
        Base.metadata.create_all(bind=engine)
        db = Session(bind=engine)
        yield db
        db.close()
>       Base.metadata.drop_all(bind=engine)

tests\test_task_management.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\sql\schema.py:5956: in drop_all
    bind._run_ddl_visitor(
venv\Lib\site-packages\sqlalchemy\engine\base.py:3260: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv\Lib\site-packages\sqlalchemy\engine\base.py:2467: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.sql.ddl.SchemaDropper object at 0x000001D36E179F90>
metadata = MetaData()

    def visit_metadata(self, metadata):
        if self.tables is not None:
            tables = self.tables
        else:
            tables = list(metadata.tables.values())
    
        try:
            unsorted_tables = [t for t in tables if self._can_drop_table(t)]
            collection = list(
                reversed(
                    sort_tables_and_constraints(
                        unsorted_tables,
                        filter_fn=lambda constraint: (
                            False
                            if not self.dialect.supports_alter
                            or constraint.name is None
                            else None
                        ),
                    )
                )
            )
        except exc.CircularDependencyError as err2:
            if not self.dialect.supports_alter:
                util.warn(
                    "Can't sort tables for DROP; an "
                    "unresolvable foreign key "
                    "dependency exists between tables: %s; and backend does "
                    "not support ALTER.  To restore at least a partial sort, "
                    "apply use_alter=True to ForeignKey and "
                    "ForeignKeyConstraint "
                    "objects involved in the cycle to mark these as known "
                    "cycles that will be ignored."
                    % (", ".join(sorted([t.fullname for t in err2.cycles])))
                )
                collection = [(t, ()) for t in unsorted_tables]
            else:
>               raise exc.CircularDependencyError(
                    err2.args[0],
                    err2.cycles,
                    err2.edges,
                    msg="Can't sort tables for DROP; an "
                    "unresolvable foreign key "
                    "dependency exists between tables: %s.  Please ensure "
                    "that the ForeignKey and ForeignKeyConstraint objects "
                    "involved in the cycle have "
                    "names so that they can be dropped using "
                    "DROP CONSTRAINT."
                    % (", ".join(sorted([t.fullname for t in err2.cycles]))),
                ) from err2
E               sqlalchemy.exc.CircularDependencyError: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: teams, users.  Please ensure that the ForeignKey and ForeignKeyConstraint objects involved in the cycle have names so that they can be dropped using DROP CONSTRAINT.

venv\Lib\site-packages\sqlalchemy\sql\ddl.py:1113: CircularDependencyError
=========================== short test summary info ===========================
ERROR tests/test_task_management.py::test_task_lifecycle_with_subtasks - sqla...
ERROR tests/test_task_management.py::test_task_lifecycle_with_subtasks - sqla...
============================== 2 errors in 1.56s ==============================
